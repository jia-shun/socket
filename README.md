### NIO：
是基于事件、通知模型：
基于观察者模式：观察者注册事件，服务方通知观察者。
1：JVM是观察者，JVM进程启动的时候向Linux内核绑定ip+port注册连接接入事件。
2：当有连接开始请求这个ip和端口的时候，通知JVM，JVM吊起我们的应用程序。
3：通知。我们程序中有一个线程Selector()轮询器去轮询内核的连接池子(可以理解为一个集合)，
谁往这个池子添加东西呢？就是Linux内核。收到客户端请求连接就将连接添加至池子。
这些连接都是有标示的，不会乱。底层已经区分好了。
4：内核和客户端建立连接。连接状态：成功，超时，断开。。。当连接成功，Selector()监听到事件。
5：内核告诉前端我们连接成功，可以传输数据了。从而完成了TCP的三次握手。
6：Selector()又一次从池子中监听到连接成功的事件。一次连接就完成了。
下面就开始发送数据：
7：接收数据。首先内核和客户端传输数据，数据内核OS操作系统交互完成数据传输。数据有几个状态：isRead
8：此时轮询器如果检测到有一个连接是isRead状态的事件。
9：此时就可以直接读数据了。此时是OS内核和JVM中的应用进行交互。此时OS内核中有一个Buffer的缓冲区。JVM从缓冲区去读。
10：JVM中有一个Buffer的对象引用，这个引用就是指针，指向OS内核里面的buffer内存，这一层是JVM帮我们实现的。
11：我们应用程序中可以调用Buffer对象。调取方法通过channel将OS内核buffer内存将数据读入。此时我们就可以做我们的逻辑处理。
12：而这个channel是一个双向管道。处理完数据之后，通过channel写回OS内核buffer内存区。然后OS收到指令，cpu将数据返回给客户端。
这个channel和连接池中的连接一样，都是有标示的。
Selector()轮询的事件就是一个个的selectKey。

**Tomcat调优：将server.xml中的connector的protocol改成nio是一种方式。**

### AIO:和底层连接的更密切，连selector()都省了。

### RPC：
使用技术：Spring IOC AOP 扫描注解 ，反射+动态代理
目标：服务A远程调用服务B的接口。
1：通过注解注入一个接口。
2：通过反射生成一个动态代理类。
3：当调用接口的方法时，进行AOP拦截。实际上是调用的代理类的invoke方法。
4：在吊起代理类的invoke方法时，我们开启Socket使用netty将注入的接口和实现类封装成一个Request经过序列化发送至远程的服务器B。
5：远程服务器B收到请求，反序列化解析请求并返回序列化的结果。
6：服务A将结果返回给客户端。

### Netty:


























